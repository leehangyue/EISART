"""
EISART GUI Support Module
Coded by Hangyue Li, Tsinghua University
"""
# /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 5.4
#  in conjunction with Tcl version 8.6
#    Sep 08, 2020 04:24:03 PM CST  platform: Windows NT

import sys
from os import path, listdir
if 'np' not in sys.modules:
    import numpy as np

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

cd = path.dirname(__file__)
sys.path.append(cd)
import EISART_kernel
from util_io import supported_extension, ECM_ZView_IO
from util_plot import PlotRanges, plot_manual_peaks, Handle
from util_ecm import ManualECMElement, ManualECMPars
sys.path.pop()

EISART_kernel.connected_to_gui = True
batch_save_data = True
area = 1.0
R_inf_set = None
L_set = [None, None]
plot_ranges = PlotRanges(filename=EISART_kernel.plot_ranges_file)
manual_ecm_pars = ManualECMPars()
last_peak_id = 1
hdl = Handle()


def set_Tk_var():
    global combobox_sav_fmt
    combobox_sav_fmt = tk.StringVar()
    global txt_var_lmd
    txt_var_lmd = tk.StringVar()
    global txt_var_R_inf
    txt_var_R_inf = tk.StringVar()
    global txt_var_L_self
    txt_var_L_self = tk.StringVar()
    global txt_var_L_wire
    txt_var_L_wire = tk.StringVar()
    global spinbox_wt_iter
    spinbox_wt_iter = tk.IntVar()
    global spinbox_flt_lvl
    spinbox_flt_lvl = tk.DoubleVar()
    global che_kk
    che_kk = tk.BooleanVar()
    global spinbox_auto_lmd_rad
    spinbox_auto_lmd_rad = tk.DoubleVar()
    global spinbox_eis_lf_dis
    spinbox_eis_lf_dis = tk.DoubleVar()
    global spinbox_eis_hf_dis
    spinbox_eis_hf_dis = tk.DoubleVar()
    global spinbox_drt_lf_ext
    spinbox_drt_lf_ext = tk.DoubleVar()
    global spinbox_drt_hf_ext
    spinbox_drt_hf_ext = tk.DoubleVar()
    global che_fls_pk_sup
    che_fls_pk_sup = tk.BooleanVar()
    global spinbox_max_trim
    spinbox_max_trim = tk.IntVar()
    global spinbox_trim_unskip
    spinbox_trim_unskip = tk.IntVar()
    global spinbox_max_num_pk
    spinbox_max_num_pk = tk.IntVar()
    global spinbox_pk_damp_dec
    spinbox_pk_damp_dec = tk.DoubleVar()
    global che_eis_line
    che_eis_line = tk.BooleanVar()
    global che_show_tau
    che_show_tau = tk.BooleanVar()
    global che_true_drt_false_ecm
    che_true_drt_false_ecm = tk.BooleanVar()
    global txt_var_gerischer_pos
    txt_var_gerischer_pos = tk.StringVar()
    global che_plt_each
    che_plt_each = tk.BooleanVar()
    global che_sav_dat
    che_sav_dat = tk.BooleanVar()
    global che_sav_plt
    che_sav_plt = tk.BooleanVar()
    global che_sav_resi
    che_sav_resi = tk.BooleanVar()
    global che_cnv_ism
    che_cnv_ism = tk.BooleanVar()
    global che_sav_ecm_eis_drt
    che_sav_ecm_eis_drt = tk.BooleanVar()
    global che_sav_ref_drt
    che_sav_ref_drt = tk.BooleanVar()
    global che_sav_weights
    che_sav_weights = tk.BooleanVar()
    global che_eis_fit
    che_eis_fit = tk.BooleanVar()
    global che_eis_fit_tau
    che_eis_fit_tau = tk.BooleanVar()
    global che_eis_fit_iterate_alpha
    che_eis_fit_iterate_alpha = tk.BooleanVar()
    global che_eis_fit_elementwise
    che_eis_fit_elementwise = tk.BooleanVar()
    global che_cdrt_fit_coupled
    che_cdrt_fit_coupled = tk.BooleanVar()
    global che_cdrt_fit_refresh
    che_cdrt_fit_refresh = tk.BooleanVar()
    global che_cdrt_fit_r
    che_cdrt_fit_r = tk.BooleanVar()
    global che_cdrt_fit_tau
    che_cdrt_fit_tau = tk.BooleanVar()
    global che_cdrt_fit_alpha
    che_cdrt_fit_alpha = tk.BooleanVar()
    global che_auto_lmd
    che_auto_lmd = tk.BooleanVar()
    global che_auto_peak_detect
    che_auto_peak_detect = tk.BooleanVar()  # added on 20201208
    global spinbox_m_ecm_id
    spinbox_m_ecm_id = tk.IntVar()  # added on 20201208
    global spinbox_m_ecm_total
    spinbox_m_ecm_total = tk.IntVar()  # added on 20201208
    global txt_m_ecm_label
    txt_m_ecm_label = tk.StringVar()  # added on 20201208
    global txt_m_ecm_min
    txt_m_ecm_min = tk.StringVar()  # added on 20201208
    global txt_m_ecm_max
    txt_m_ecm_max = tk.StringVar()  # added on 20201208
    global txt_m_ecm_alpha_min
    txt_m_ecm_alpha_min = tk.StringVar()  # added on 20201208
    global txt_m_ecm_alpha_max
    txt_m_ecm_alpha_max = tk.StringVar()  # added on 20201208
    global che_m_ecm_isG
    che_m_ecm_isG = tk.BooleanVar()  # added on 20201220
    global che_m_ecm_fixed
    che_m_ecm_fixed = tk.BooleanVar()  # added on 20201220
    global txt_var_area
    txt_var_area = tk.StringVar()
    global scrolledtext_terminal
    # In EISART: EISART_support.scrolledtext_terminal = self.Scrolledtext_terminal
    global fig_gui
    # In EISART: EISART_support.fig_gui = fig_gui
    global canvas_gui
    # In EISART: EISART_support.canvas_gui = self.Canvas1
    global fig_m_peak
    # In EISART: EISART_support.fig_m_peak = fig_m_peak
    global canvas_m_peak
    # In EISART: EISART_support.canvas_m_peak = self.Canvas2
    global path_text_entry
    # In EISART: EISART_support.path_text_entry = self.Entry_browse_path
    global message_bar
    # In EISART: EISART_support.message_bar = self.Message_state
    global progress_bar_var
    progress_bar_var = tk.IntVar()
    global drt_ecm_settings_notebook
    # In EISART: EISART_support.drt_ecm_settings_notebook = self.TNotebook_drt_ecm_settings
    global ctrl_nb
    # In EISART: EISART_support.ctrl_nb = self.TNotebook_Browse_settings
    global ctrl_nb_terminal
    # In EISART: EISART_support.ctrl_nb_terminal = self.TNotebook_Browse_settings_t3
    global filelist
    # In EISART: EISART_support.filelist = self.Scrolledtreeview_filelist
    # Reference: https://www.askpython.com/python-modules/tkinter/tkinter-treeview-widget
    # global filelist
    # import random
    # iid = str(random.random())
    # filelist.insert(parent='', index='end', text='text' + iid, values='values' + iid)
    # https://stackoverflow.com/questions/22812134/how-to-clear-an-entire-treeview-with-tkinter
    # filelist.delete(*filelist.get_children())
    # https://stackoverflow.com/questions/48867800/tk-treeview-focus-how-do-i-get-multiple-selected-lines
    # print(str(filelist.item(filelist.selection()[0])['values']))
    # Double click reference:
    # https://stackoverflow.com/questions/3794268/command-for-clicking-on-the-items-of-a-tkinter-treeview-widget
    global txt_plot_range_z_re_min
    txt_plot_range_z_re_min = tk.StringVar()
    global txt_plot_range_z_re_max
    txt_plot_range_z_re_max = tk.StringVar()
    global txt_plot_range_z_im_min
    txt_plot_range_z_im_min = tk.StringVar()
    global txt_plot_range_z_im_max
    txt_plot_range_z_im_max = tk.StringVar()
    global txt_plot_range_eis_f_min
    txt_plot_range_eis_f_min = tk.StringVar()
    global txt_plot_range_eis_f_max
    txt_plot_range_eis_f_max = tk.StringVar()
    global txt_plot_range_drt_g_min
    txt_plot_range_drt_g_min = tk.StringVar()
    global txt_plot_range_drt_g_max
    txt_plot_range_drt_g_max = tk.StringVar()
    global txt_plot_range_drt_x_min
    txt_plot_range_drt_x_min = tk.StringVar()
    global txt_plot_range_drt_x_max
    txt_plot_range_drt_x_max = tk.StringVar()
    global label_plot_range_drt_x_min
    # In EISART: EISART_support.label_plot_range_drt_x_min = self.Label_plot_range_drt_x_min
    global label_plot_range_drt_x_unit
    # In EISART: EISART_support.label_plot_range_drt_x_unit = self.Label_plot_range_drt_x_unit
    global label_manual_peak_min
    # In EISART: EISART_support.label_manual_peak_min = self.Label_manual_peak_min
    global label_manual_peak_to
    # In EISART: EISART_support.label_manual_peak_to = self.Label_manual_peak_to
    global label_manual_peak_max
    # In EISART: EISART_support.label_manual_peak_max = self.Label_manual_peak_max
    global spinbox_tk_manual_peak_id
    # In EISART: EISART_support.spinbox_tk_manual_peak_id = self.Spinbox_manual_peak_id
    global spinbox_tk_manual_peak_total
    # In EISART: EISART_support.spinbox_tk_manual_peak_total = self.Spinbox_manual_peak_total
    global txt_plot_range_res_min
    txt_plot_range_res_min = tk.StringVar()
    global txt_plot_range_res_max
    txt_plot_range_res_max = tk.StringVar()
    global plot_ranges_enable
    plot_ranges_enable = tk.BooleanVar()


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    load_settings_into_gui()
    spinbox_m_ecm_id.set(1)
    spinbox_m_ecm_total.set(manual_ecm_pars.n)
    plot_manual_ecm_element_into_gui(initializing=True)
    load_manual_ecm_element_into_gui(elem=manual_ecm_pars.get(1))


def get_settings_from_gui():
    settings = EISART_kernel.settings
    settings.drt_show_LR = False
    # get current tab reference:
    #   https://stackoverflow.com/questions/14000944/finding-the-currently-selected-tab-of-ttk-notebook
    settings.drt_not_ecm = che_true_drt_false_ecm.get()
    settings.save_fmt = combobox_sav_fmt.get()
    settings.lmd = parse_float(txt_var_lmd, default=1e-3)
    settings.weight_iter = get_spinbox_value(spinbox_wt_iter, default=settings.weight_iter)
    settings.flt_level = get_spinbox_value(spinbox_flt_lvl, default=settings.flt_level)
    settings.kk_test = che_kk.get()
    settings.auto_lmd = che_auto_lmd.get()
    settings.auto_lmd_radius_dec = get_spinbox_value(spinbox_auto_lmd_rad, default=settings.auto_lmd_radius_dec)
    settings.eis_lo_f_discard_decades = get_spinbox_value(spinbox_eis_lf_dis, default=settings.eis_lo_f_discard_decades)
    settings.eis_hi_f_discard_decades = get_spinbox_value(spinbox_eis_hf_dis, default=settings.eis_hi_f_discard_decades)
    settings.drt_lo_f_extension_decades = get_spinbox_value(spinbox_drt_lf_ext, default=settings.drt_lo_f_extension_decades)
    settings.drt_hi_f_extension_decades = get_spinbox_value(spinbox_drt_hf_ext, default=settings.drt_hi_f_extension_decades)
    settings.drt_false_peak_suppress = che_fls_pk_sup.get()
    settings.max_trim = get_spinbox_value(spinbox_max_trim, settings.max_trim)
    settings.trim_unskip = get_spinbox_value(spinbox_trim_unskip, settings.trim_unskip)
    settings.max_num_peak = get_spinbox_value(spinbox_max_num_pk, settings.max_num_peak)
    settings.peak_damp_dec = get_spinbox_value(spinbox_pk_damp_dec, settings.peak_damp_dec)
    settings.eis_draw_lines = che_eis_line.get()
    settings.drt_show_tau = che_show_tau.get()
    try:
        value = list(eval('[' + txt_var_gerischer_pos.get() + ']'))
        settings.gerischer_positions = value
    except NameError:
        txt_var_gerischer_pos.set(str(settings.gerischer_positions)[1:-1])
    except SyntaxError:
        txt_var_gerischer_pos.set(str(settings.gerischer_positions)[1:-1])
    settings.show_plot = che_plt_each.get()
    global batch_save_data
    batch_save_data = che_sav_dat.get()
    settings.save_plot = che_sav_plt.get()
    settings.save_residuals = che_sav_resi.get()
    settings.save_weights = che_sav_weights.get()
    settings.convert_ism = che_cnv_ism.get()
    settings.save_ecm_eis_drt = che_sav_ecm_eis_drt.get()
    settings.save_ref_drt = che_sav_ref_drt.get()
    settings.eis_fit = che_eis_fit.get()
    settings.eis_fit_tau = che_eis_fit_tau.get()
    settings.eis_fit_refresh_alpha = che_eis_fit_iterate_alpha.get()  # Ahhhh naming is a headache...
    settings.eis_fit_elementwise = che_eis_fit_elementwise.get()
    settings.cdrt_fit_coupled = che_cdrt_fit_coupled.get()
    settings.cdrt_fit_refresh_from_new = che_cdrt_fit_refresh.get()
    settings.cdrt_fit_R = che_cdrt_fit_r.get()
    settings.cdrt_fit_tau = che_cdrt_fit_tau.get()
    settings.cdrt_fit_alpha = che_cdrt_fit_alpha.get()
    settings.auto_peak_detect = che_auto_peak_detect.get()
    EISART_kernel.settings = settings
    global area
    area = parse_float(txt_var_area, default=1.0)
    _get_plot_ranges_from_gui()
    global R_inf_set
    R_inf_set = parse_float(txt_var_R_inf, default=float('nan'))
    if np.isnan(R_inf_set):
        R_inf_set = None
        txt_var_R_inf.set('')
    L_self = parse_float(txt_var_L_self, default=float('nan')) / 1e6  # uH in GUI, H in background processes
    if np.isnan(L_self):
        L_self = None
        txt_var_L_self.set('')
    L_wire = parse_float(txt_var_L_wire, default=float('nan')) / 1e6  # uH in GUI, H in background processes
    if np.isnan(L_wire):
        L_wire = None
        txt_var_L_wire.set('')
    global L_set
    L_set = [L_self, L_wire]


def _get_plot_ranges_from_gui():
    settings = EISART_kernel.settings
    nan = float('nan')
    plot_ranges.z_re_min = parse_float(txt_plot_range_z_re_min, default=nan)
    plot_ranges.z_re_max = parse_float(txt_plot_range_z_re_max, default=nan)
    plot_ranges.z_im_min = parse_float(txt_plot_range_z_im_min, default=nan)
    plot_ranges.z_im_max = parse_float(txt_plot_range_z_im_max, default=nan)
    plot_ranges.eis_f_min = parse_float(txt_plot_range_eis_f_min, default=nan)
    plot_ranges.eis_f_max = parse_float(txt_plot_range_eis_f_max, default=nan)
    plot_ranges.drt_g_min = parse_float(txt_plot_range_drt_g_min, default=nan)
    plot_ranges.drt_g_max = parse_float(txt_plot_range_drt_g_max, default=nan)
    if settings.drt_show_tau:
        plot_ranges.drt_t_min = parse_float(txt_plot_range_drt_x_min, default=nan)
        plot_ranges.drt_t_max = parse_float(txt_plot_range_drt_x_max, default=nan)
    else:
        from numpy import pi
        plot_ranges.drt_t_min = 1 / (2 * pi * parse_float(txt_plot_range_drt_x_max, default=nan))
        plot_ranges.drt_t_max = 1 / (2 * pi * parse_float(txt_plot_range_drt_x_min, default=nan))
    plot_ranges.res_min = parse_float(txt_plot_range_res_min, default=nan)
    plot_ranges.res_max = parse_float(txt_plot_range_res_max, default=nan)
    plot_ranges.enable_ranges = plot_ranges_enable.get()


def load_settings_into_gui():
    EISART_kernel.load_settings()
    settings = EISART_kernel.settings
    combobox_sav_fmt.set(settings.save_fmt)
    txt_var_lmd.set(str(settings.lmd))
    spinbox_wt_iter.set(settings.weight_iter)
    spinbox_flt_lvl.set(settings.flt_level)
    che_kk.set(settings.kk_test)
    che_auto_lmd.set(settings.auto_lmd)
    spinbox_auto_lmd_rad.set(settings.auto_lmd_radius_dec)
    spinbox_eis_lf_dis.set(settings.eis_lo_f_discard_decades)
    spinbox_eis_hf_dis.set(settings.eis_hi_f_discard_decades)
    spinbox_drt_lf_ext.set(settings.drt_lo_f_extension_decades)
    spinbox_drt_hf_ext.set(settings.drt_hi_f_extension_decades)
    che_fls_pk_sup.set(settings.drt_false_peak_suppress)
    spinbox_max_trim.set(settings.max_trim)
    spinbox_trim_unskip.set(settings.trim_unskip)
    spinbox_max_num_pk.set(settings.max_num_peak)
    spinbox_pk_damp_dec.set(settings.peak_damp_dec)
    che_eis_line.set(settings.eis_draw_lines)
    che_show_tau.set(settings.drt_show_tau)
    che_true_drt_false_ecm.set(settings.drt_not_ecm)
    txt_var_gerischer_pos.set(str(settings.gerischer_positions)[1:-1])
    che_plt_each.set(settings.show_plot)
    che_sav_dat.set(batch_save_data)
    che_sav_plt.set(settings.save_plot)
    che_sav_resi.set(settings.save_residuals)
    che_sav_weights.set(settings.save_weights)
    che_cnv_ism.set(settings.convert_ism)
    che_sav_ecm_eis_drt.set(settings.save_ecm_eis_drt)
    che_sav_ref_drt.set(settings.save_ref_drt)
    che_eis_fit.set(settings.eis_fit)
    che_eis_fit_tau.set(settings.eis_fit_tau)
    che_eis_fit_iterate_alpha.set(settings.eis_fit_refresh_alpha)  # Ahhhh naming is a headache...
    che_eis_fit_elementwise.set(settings.eis_fit_elementwise)
    che_cdrt_fit_coupled.set(settings.cdrt_fit_coupled)
    che_cdrt_fit_refresh.set(settings.cdrt_fit_refresh_from_new)
    che_cdrt_fit_r.set(settings.cdrt_fit_R)
    che_cdrt_fit_tau.set(settings.cdrt_fit_tau)
    che_cdrt_fit_alpha.set(settings.cdrt_fit_alpha)
    che_auto_peak_detect.set(settings.auto_peak_detect)
    txt_var_area.set(area)
    _load_plot_ranges_into_gui()
    if R_inf_set is None:
        txt_var_R_inf.set('')
    else:
        txt_var_R_inf.set(R_inf_set)
    if L_set[0] is None:
        txt_var_L_self.set('')
    else:
        txt_var_L_self.set(L_set[0] * 1e6)  # uH in GUI, H in background processes
    if L_set[1] is None:
        txt_var_L_wire.set('')
    else:
        txt_var_L_wire.set(L_set[1] * 1e6)  # uH in GUI, H in background processes
    root.update_idletasks()


def _load_plot_ranges_into_gui():
    settings = EISART_kernel.settings
    txt_plot_range_z_re_min.set(str(plot_ranges.z_re_min))
    txt_plot_range_z_re_max.set(str(plot_ranges.z_re_max))
    txt_plot_range_z_im_min.set(str(plot_ranges.z_im_min))
    txt_plot_range_z_im_max.set(str(plot_ranges.z_im_max))
    txt_plot_range_eis_f_min.set("{:.1e}".format(plot_ranges.eis_f_min))
    txt_plot_range_eis_f_max.set("{:.1e}".format(plot_ranges.eis_f_max))
    txt_plot_range_drt_g_min.set(str(plot_ranges.drt_g_min))
    txt_plot_range_drt_g_max.set(str(plot_ranges.drt_g_max))
    if settings.drt_show_tau:
        txt_plot_range_drt_x_min.set("{:.1e}".format(plot_ranges.drt_t_min))
        txt_plot_range_drt_x_max.set("{:.1e}".format(plot_ranges.drt_t_max))
    else:
        from numpy import pi
        txt_plot_range_drt_x_min.set("{:.1e}".format(1 / (2 * pi * plot_ranges.drt_t_max)))
        txt_plot_range_drt_x_max.set("{:.1e}".format(1 / (2 * pi * plot_ranges.drt_t_min)))
    txt_plot_range_res_min.set(str(plot_ranges.res_min))
    txt_plot_range_res_max.set(str(plot_ranges.res_max))
    plot_ranges_enable.set(plot_ranges.enable_ranges)


def print_to_gui(string, file=None):
    # reference:
    #   https://stackoverflow.com/questions/30669015/autoscroll-of-text-and-scrollbar-in-python-text-box/48154818
    if file is None:
        file = scrolledtext_terminal
    file.insert('end', string + '\n')
    file.see("end")
    root.update_idletasks()


def read_manual_ecm_element_from_gui():
    peak_min = parse_float(txt_m_ecm_min, default=1e-3)
    peak_max = parse_float(txt_m_ecm_max, default=1e3)
    if che_show_tau.get():  # peak_min is tau
        tau_min = peak_min
        tau_max = peak_max
    else:  # peak_min is frequency
        tau_min = 1 / (2 * np.pi * peak_max)
        tau_max = 1 / (2 * np.pi * peak_min)
    alpha_min = parse_float(txt_m_ecm_alpha_min, default=0.4)
    alpha_max = parse_float(txt_m_ecm_alpha_max, default=1.0)
    elem = ManualECMElement()
    name = txt_m_ecm_label.get()
    elem.label = name
    elem.taumin = tau_min
    elem.taumax = tau_max
    elem.tau = np.sqrt(tau_max * tau_min)
    elem.alphamin = alpha_min
    elem.alphamax = alpha_max
    elem.alpha = (alpha_min + alpha_max) / 2
    elem.isGerischer = che_m_ecm_isG.get()
    elem.fixed = che_m_ecm_fixed.get()
    load_manual_ecm_element_into_gui(elem)  # show actual values after setting
    return elem


def load_manual_ecm_element_into_gui(elem):
    taumin = elem.taumin
    taumax = elem.taumax
    if che_show_tau.get():  # gui shows tau
        txt_m_ecm_min.set("%.2e" % taumin)
        txt_m_ecm_max.set("%.2e" % taumax)
    else:  # gui shows frequency
        txt_m_ecm_min.set("%.2e" % (1.0 / (2 * np.pi * taumax)))
        txt_m_ecm_max.set("%.2e" % (1.0 / (2 * np.pi * taumin)))
    alphamin = elem.alphamin
    alphamax = elem.alphamax
    txt_m_ecm_alpha_min.set("%.2f" % alphamin)
    txt_m_ecm_alpha_max.set("%.2f" % alphamax)
    txt_m_ecm_label.set(elem.label)
    che_m_ecm_isG.set(elem.isGerischer)
    che_m_ecm_fixed.set(elem.fixed)
    root.update_idletasks()


def plot_manual_ecm_element_into_gui(current_drt_data=None, initializing=False):
    hdl.fig = fig_m_peak
    if initializing:
        plot_manual_peaks(hdl=hdl)
        root.update_idletasks()
        return
    if not EISART_kernel.settings.auto_peak_detect:
        if current_drt_data is None:
            current_drt_data = _get_current_drt()
        L, R_inf, gamma, tau_out, phi, weights, settings = current_drt_data
        if isinstance(settings, EISART_kernel.Settings):
            show_tau = settings.drt_show_tau
        else:
            EISART_kernel.settings.load(EISART_kernel.settings_file)
            show_tau = EISART_kernel.settings.drt_show_tau
        plot_manual_peaks(tau_out, gamma, manual_ecm_pars, show_tau=show_tau, hdl=hdl)
        canvas_m_peak.draw()
    root.update_idletasks()


def command_manual_peak_pars_redraw(event=None):
    _command_manual_peak_pars(redraw=True)


def command_manual_peak_pars(event=None):
    _command_manual_peak_pars(redraw=False)


def _command_manual_peak_pars(redraw=True):
    peak_id = last_peak_id
    elem = read_manual_ecm_element_from_gui()
    manual_ecm_pars.set(peak_id, elem)
    if redraw:
        plot_manual_ecm_element_into_gui()


def command_manual_peak_id(event=None, update_prev_element=True):
    if update_prev_element:  # save changes on the previous element before changing the peak id
        command_manual_peak_pars()
    peak_id = spinbox_m_ecm_id.get()
    elem = manual_ecm_pars.get(peak_id)
    load_manual_ecm_element_into_gui(elem)
    global last_peak_id
    last_peak_id = peak_id


def command_manual_peak_total(event=None):
    spinbox_tk_manual_peak_total.configure(state='disabled')  # lock the spinbox
    n_new = spinbox_m_ecm_total.get()
    n_old = manual_ecm_pars.n
    if n_new < n_old:
        from tkinter.messagebox import askyesno
        peak_id = spinbox_m_ecm_id.get()
        elem = manual_ecm_pars.get(peak_id)
        message = 'Do you wish to delete the following element?\n\n' + str(elem).replace(', \'', ',\n\'')
        answer = askyesno(title='Delete an element', message=message)
        if answer:  # delete
            manual_ecm_pars.remove(peak_id)
            spinbox_tk_manual_peak_id.configure(to=n_new)
            if peak_id > n_new:
                spinbox_m_ecm_id.set(n_new)
            command_manual_peak_id(update_prev_element=False)
            plot_manual_ecm_element_into_gui()
        else:  # not delete
            spinbox_m_ecm_total.set(manual_ecm_pars.n)
            root.update_idletasks()
    elif n_new > n_old:
        answer = popupmsg(title="Add an element", msg="How do you wish to add the element?",
                          button1='Insert', button2='Append', button3='Cancel')
        if answer is None:
            spinbox_m_ecm_total.set(manual_ecm_pars.n)
            root.update_idletasks()
            spinbox_tk_manual_peak_total.configure(state='normal')  # unlock the spinbox
            return
        command_manual_peak_id()
        spinbox_tk_manual_peak_id.configure(to=n_new)
        from util_ecm import ManualECMElement
        elem = ManualECMElement()
        if answer:  # insert
            peak_id = spinbox_m_ecm_id.get()
            manual_ecm_pars.insert(index=peak_id, elem=elem)
        else:  # append
            manual_ecm_pars.append(elem=elem)
            spinbox_m_ecm_id.set(n_new)
            global last_peak_id
            last_peak_id = n_new
        plot_manual_ecm_element_into_gui()
        load_manual_ecm_element_into_gui(elem)
    else:  # n_new = n_old
        pass
    spinbox_tk_manual_peak_total.configure(state='normal')  # unlock the spinbox


def popupmsg(title='Title', msg='Message', button1='Button1', button2='Button2', button3='Button3'):
    # https://pythonprogramming.net/tkinter-popup-message-window/
    popup = tk.Toplevel(root)
    # https://yagisanatode.com/2018/02/24/how-to-center-the-main-window-on-the-screen-in-tkinter-with-python-3/
    windowWidth = 300
    windowHeight = 100
    positionRight = int(root.winfo_screenwidth() / 2 - windowWidth / 2)
    positionDown = int(root.winfo_screenheight() / 2 - windowHeight / 2)
    popup.geometry("{}x{}+{}+{}".format(windowWidth, windowHeight, positionRight, positionDown))  # center the dialog
    popup.resizable(0, 0)
    popup.wm_title(title)
    label = tk.Label(popup, text=msg)
    label.place(relx=0.0, rely=0.2, relheight=0.3, relwidth=1.0)
    answer = [None, ]
    focus_id = [0, ]  # force using method-wide variable in move_focus

    def cmd1(event=None):
        answer[0] = True  # access the external variable
        popup.destroy()

    def cmd2(event=None):
        answer[0] = False  # access the external variable
        popup.destroy()

    def cmd3(event=None):
        popup.destroy()

    def bind_button(Button):
        Button.bind('<Left>', move_focus_left)
        Button.bind('<Right>', move_focus_right)

    def move_focus_left(event=None):
        focus_id[0] = (focus_id[0] - 1) % 3
        set_focus()

    def move_focus_right(event=None):
        focus_id[0] = (focus_id[0] + 1) % 3
        set_focus()

    def set_focus():
        if focus_id[0] == 0:
            B1.focus_set()
        elif focus_id[0] == 1:
            B2.focus_set()
        elif focus_id[0] == 2:
            B3.focus_set()
        else:
            pass
    B1 = tk.Button(popup, text=button1, command=cmd1)
    B1.bind('<Return>', cmd1)
    bind_button(B1)
    B1.place(relx=0.1, rely=0.6, relheight=0.3, relwidth=0.2)
    B2 = tk.Button(popup, text=button2, command=cmd2)
    B2.bind('<Return>', cmd2)
    bind_button(B2)
    B2.place(relx=0.4, rely=0.6, relheight=0.3, relwidth=0.2)
    B3 = tk.Button(popup, text=button3, command=cmd3)
    B3.bind('<Return>', cmd3)
    bind_button(B3)
    B3.place(relx=0.7, rely=0.6, relheight=0.3, relwidth=0.2)
    B1.focus_set()
    popup.wait_window()
    return answer[0]

def parse_float(string_var, default=0.0):
    try:
        return float(string_var.get())
    except ValueError:
        try:
            string_var.set(str(default))
            return default
        except ValueError:
            print('Parse failed: string_var = ' + string_var.get() + ', default = ' + str(default), file=sys.stderr)
            return float('nan')

def get_spinbox_value(spinbox_var, default=0.0):
    try:
        value = spinbox_var.get()
        return value
    except tk.TclError:
        spinbox_wt_iter.set(str(default))
        return default

def list_dir_in_filelist(directory, filename=None):
    filelist.delete(*filelist.get_children())
    try:
        namelist = listdir(directory)
    except FileNotFoundError:
        namelist = []
    supported_file_count = 0
    supported_namelist = []
    for name in namelist:
        ext = path.splitext(name)[-1][1:]  # remove the dot '.' before extension, i.e. '.txt' -> 'txt'
        if ext not in supported_extension:
            continue
        full_name = path.join(directory, name)
        filelist.insert(parent='', index='end', text=name, values=[full_name, ])
        supported_namelist.append(name)
        supported_file_count += 1
    if filename is not None:
        filename = path.split(filename)[1]
        if filename and filename in supported_namelist:  # if len(filename) > 0 and filename in nameList
            try:
                filename_id = supported_namelist.index(filename)
                child_id = filelist.get_children()[filename_id]
                filelist.focus(child_id)
                filelist.selection_set(child_id)
            except ValueError:
                pass
    if supported_file_count > 0:
        message_set('Ready.')

def message_set(string):
    message_bar.configure(text=string)
    root.update_idletasks()

def refresh_gui():
    fig_gui.patch.set_facecolor('#ffffff')
    canvas_gui.draw()
    root.update_idletasks()

def command_show_tau(event=None):  # called when the show_tau checkbox is clicked on
    global label_plot_range_drt_x_min
    global label_plot_range_drt_x_unit
    global che_show_tau
    if che_show_tau.get():
        label_plot_range_drt_x_min.configure(text="tau from")
        label_plot_range_drt_x_unit.configure(text="s")
        label_manual_peak_min.configure(text=" tau from")
        label_manual_peak_to.configure(text="  s  to ")
        label_manual_peak_max.configure(text=" s ")
    else:
        label_plot_range_drt_x_min.configure(text="Eig.Freq. from")
        label_plot_range_drt_x_unit.configure(text="Hz")
        label_manual_peak_min.configure(text="Freq from")
        label_manual_peak_to.configure(text=" Hz  to ")
        label_manual_peak_max.configure(text=" Hz ")

    def convert_tau_f(string_var_min, string_var_max, decplace=3):
        decplace = int(decplace)
        if decplace < 0:
            decplace = 0
        nan = float('nan')
        from numpy import pi
        val_min = parse_float(string_var_min, default=nan)
        val_max = parse_float(string_var_max, default=nan)
        if val_min == nan:
            string_var_max.set('')
        else:
            fmt = "{:." + str(decplace) + "e}"
            string_var_max.set(fmt.format(1 / (2 * pi * val_min)))
        if val_max == nan:
            string_var_min.set('')
        else:
            fmt = "{:." + str(decplace) + "e}"
            string_var_min.set(fmt.format(1 / (2 * pi * val_max)))

    global txt_plot_range_drt_x_min
    global txt_plot_range_drt_x_max
    convert_tau_f(txt_plot_range_drt_x_min, txt_plot_range_drt_x_max, decplace=1)
    global txt_m_ecm_min
    global txt_m_ecm_max
    convert_tau_f(txt_m_ecm_min, txt_m_ecm_max, decplace=2)
    plot_manual_ecm_element_into_gui()
    root.update_idletasks()

def reset_plot_ranges():
    global plot_ranges
    plot_ranges = PlotRanges()
    _load_plot_ranges_into_gui()
    root.update_idletasks()

def _get_full_filename(get_dir=False, change_gui=True):
    global progress_bar_var
    if get_dir:
        full_filename = path_text_entry.get()  # full directory name
        if not full_filename:
            if change_gui:
                message_set('Please select a file!')
                fig_gui.clear()
                fig_gui.patch.set_facecolor('#6b768f')
                progress_bar_var.set(0)
                canvas_gui.draw()
            return ''
    else:  # get file
        try:
            full_filename = str(filelist.item(filelist.selection()[0])['values'][0])
        except IndexError:  # nothing selected
            if change_gui:
                message_set('Please select a file!')
                fig_gui.clear()
                fig_gui.patch.set_facecolor('#6b768f')
                progress_bar_var.set(0)
                canvas_gui.draw()
            return ''
    return full_filename

def run_kernel(save_results=True, batch=False):
    global progress_bar_var
    progress_bar_var.set(0)
    full_filename = _get_full_filename(get_dir=batch)
    if not full_filename:
        return 1
    message_set('Working...')
    get_settings_from_gui()
    settings = EISART_kernel.settings

    if not (settings.drt_not_ecm or settings.auto_peak_detect):
        command_manual_peak_pars_redraw()

    if not settings.drt_not_ecm:  # if show ECM results, disable kk_test mode
        settings.kk_test = False
        EISART_kernel.settings = settings
        settings.save(filename=EISART_kernel.settings_file)
        load_settings_into_gui()

    show_plot_backup = settings.show_plot
    if not batch:
        settings.show_plot = True
    settings.save(filename=EISART_kernel.settings_file)  # save whether or not batch
    plot_ranges.save(filename=EISART_kernel.plot_ranges_file)

    sucess_count = 0
    if batch:  # set active tab in notebook in GUI
        global ctrl_nb, ctrl_nb_terminal
        # https://python-forum.io/Thread-Tkinter-Notebook-accessing-a-specific-tab-using-a-button-from-a-toplevel-frame
        ctrl_nb.select(ctrl_nb_terminal)
        nameList = listdir(full_filename)
        nameList = [path.join(full_filename, filename) for filename in nameList]
        n_name = len(nameList)
        if not show_plot_backup:
            fig_gui.clear()
            fig_gui.patch.set_facecolor('#6b768f')
            canvas_gui.draw()
        for i_name, name in enumerate(nameList):
            if path.isdir(name):
                continue
            fig_gui.clear()
            exit_code = EISART_kernel.kernel_main(area=area, head=name, save_results=save_results,
                                                  R_inf_set=R_inf_set, L_set=L_set)
            progress_bar_var.set(int(100 * (i_name + 1) / n_name))
            if exit_code == 0 and show_plot_backup:
                sucess_count += 1
                fig_gui.patch.set_facecolor('#ffffff')
                canvas_gui.draw()
            fig_gui.waitforbuttonpress(timeout=1e-3)
            root.update_idletasks()
        progress_bar_var.set(100)
        if sucess_count == 0:
            fig_gui.patch.set_facecolor('#6b768f')
            canvas_gui.draw()
        if save_results:
            message_set('Results saved for ' + str(sucess_count) + ' files.')
        else:
            message_set('Done.')
    else:  # not batch
        progress_bar_var.set(20)
        root.update_idletasks()
        fig_gui.clear()
        exit_code = EISART_kernel.kernel_main(area=area, head=full_filename, save_results=save_results,
                                              R_inf_set=R_inf_set, L_set=L_set)

        progress_bar_var.set(80)
        root.update_idletasks()
        if exit_code == 0:
            fig_gui.patch.set_facecolor('#ffffff')
            sucess_count = 1
            # reference: https://stackoverflow.com/questions/30774281/update-matplotlib-plot-in-tkinter-gui
            canvas_gui.draw()
            progress_bar_var.set(100)
        else:
            fig_gui.clear()
            fig_gui.patch.set_facecolor('#6b768f')
            progress_bar_var.set(0)
            # reference: https://stackoverflow.com/questions/30774281/update-matplotlib-plot-in-tkinter-gui
            canvas_gui.draw()
        if save_results:
            message_set('Results saved.')
        else:
            message_set('Done.')
        settings.show_plot = show_plot_backup
        settings.save(filename=EISART_kernel.settings_file)  # save again only if batch

    if sucess_count > 0:
        plot_ranges.load(filename=EISART_kernel.plot_ranges_file)
        _load_plot_ranges_into_gui()
        plot_manual_ecm_element_into_gui()
    return 0

def command_for_Button_RefreshPlot(event=None):
    # print('EISART_support.command_for_Button_RefreshPlot')
    # sys.stdout.flush()
    run_kernel(save_results=False, batch=False)

def command_for_Button_SaveData(event=None):
    # print('EISART_support.command_for_Button_SaveData')
    # sys.stdout.flush()
    run_kernel(save_results=True, batch=False)

def command_for_Button_batch(event=None):
    # print('EISART_support.command_for_Button_batch')
    # sys.stdout.flush()
    get_settings_from_gui()  # update batch_save_data
    run_kernel(save_results=batch_save_data, batch=True)

def command_for_Button_browse(event=None):
    # print('EISART_support.command_for_Button_browse')
    # sys.stdout.flush()
    from tkinter.filedialog import askopenfilename
    title = 'Choose a folder by selecting a file'
    from util_io import supported_extension
    formats = ['.' + ext for ext in supported_extension]
    filetypes = (('Supported formats', formats), ('All files', '*'))
    filename = askopenfilename(parent=root, title=title, filetypes=filetypes)  # returns a filename
    directory = path.dirname(filename)
    if directory:  # if len(directory) > 0
        if path.isfile(directory):
            directory = path.split(directory)[0]
        list_dir_in_filelist(directory, filename)
        # reference: https://stackoverflow.com/questions/16373887/how-to-set-the-text-value-content-of-an-entry-widget-using-a-button-in-tkinter
        path_text_entry.delete(0, 'end')
        path_text_entry.insert(0, directory + '/')

def _display_m_ecm_after_loading(plot=True):
    elem = manual_ecm_pars.get(1)
    spinbox_m_ecm_id.set(1)
    load_manual_ecm_element_into_gui(elem)
    if plot:
        plot_manual_ecm_element_into_gui()
    spinbox_m_ecm_total.set(manual_ecm_pars.n)
    spinbox_tk_manual_peak_id.configure(to=manual_ecm_pars.n)
    global last_peak_id
    last_peak_id = 1
    root.update_idletasks()

def command_for_Button_load_ecm_constrains(event=None):  # an ECM constrain file
    from tkinter.filedialog import askopenfilename
    filename = askopenfilename(parent=root, title='Choose an ECM initial parameter file')
    if filename:  # if len(filename) > 0
        try:
            pars = ManualECMPars()
            pars.load(filename)
            global manual_ecm_pars
            manual_ecm_pars = pars
        except Exception:
            try:
                if not filename.endswith('mdl'):
                    raise ValueError
                mdl_io = ECM_ZView_IO()
                _, manual_ecm_pars = mdl_io.load_mdl_to_ecm_and_mecm(filename)
            except Exception:
                from tkinter.messagebox import showwarning
                showwarning(title='Loading Manual ECM...',
                            message='Failed loading manual ECM from ' + filename)
        _display_m_ecm_after_loading()

def command_for_Button_save_ecm_constrains(event=None):  # an ECM constrain file
    from tkinter.filedialog import asksaveasfilename
    filename = asksaveasfilename(parent=root, title='Save an ECM initial parameter file')
    if filename:  # if len(filename) > 0
        try:
            manual_ecm_pars.save(filename)
        except Exception:
            from tkinter.messagebox import showwarning
            showwarning(title='Saving Manual ECM...', message='Failed saving manual ECM as ' + filename)

def _get_current_drt():
    full_filename = _get_full_filename(get_dir=False, change_gui=False)
    if not full_filename:  # full_filename == ''
        return [None, ] * 7
    from util_tikhonov import DRTAnalyzer
    settings = EISART_kernel.settings
    get_settings_from_gui()
    settings.save(filename=EISART_kernel.settings_file)
    drt_settings = EISART_kernel.get_drt_settings(settings)
    ret_data = EISART_kernel.load_eis_and_trim(full_filename, area=area,
                                               eis_lo_f_discard_decades=settings.eis_lo_f_discard_decades,
                                               eis_hi_f_discard_decades=settings.eis_hi_f_discard_decades)
    eis_data = ret_data[0]
    drt_analyzer = DRTAnalyzer()
    drt_analyzer.settings = drt_settings
    freq, zre, zim = eis_data.T[0], eis_data.T[1], eis_data.T[2]
    if eis_data.shape[1] > 3:
        # elapsed_time = eis_data.T[3]
        eis_significance = eis_data.T[4]
    else:
        eis_significance = np.ones(len(freq))
    L, R_inf, gamma, tau_out, phi, weights = drt_analyzer.drt_iterative(freq, zre, zim,
                                                                        eis_significance=eis_significance)
    return L, R_inf, gamma, tau_out, phi, weights, settings

def command_for_Button_auto_ecm_constrains(event=None):  # an ECM constrain file
    from tkinter.messagebox import askokcancel
    message = 'Is it OK to overwrite the current ECM parameters?\n' + \
              'Save them as file before pressing OK if necessary.\n\n' + \
              'NOTE: Please set the total number of peaks as the maximum number of peaks.\n' + \
              'The automatically determined number of peaks may be less than the set value.'
    title = 'Auto ECM Constrains'
    if not askokcancel(title=title, message=message):
        return

    L, R_inf, gamma, tau_out, phi, weights, settings = _get_current_drt()
    if gamma is None:
        return
    from util_ecm import ECM
    ecm = ECM()
    max_num_peak = get_spinbox_value(spinbox_m_ecm_total, default=6)
    peak_indices = ecm.find_gamma_peaks(gamma, tau_out, max_n_peaks=max_num_peak, damp_dec=settings.peak_damp_dec)
    num_peak = len(peak_indices)

    def get_peak_width(peak_indices, tau):  # width in indices
        peak_indices_sorted = np.sort(peak_indices)
        peak_arg_sorted = np.argsort(peak_indices)
        peak_arg_invsort = np.argsort(peak_arg_sorted)
        widths = np.array(peak_indices_sorted) * 0.0
        len_tau = len(tau)
        n_peak = len(peak_indices_sorted)
        peak_index_distance = peak_indices_sorted[1:] - peak_indices_sorted[:-1]
        for i in range(1, n_peak - 1):
            widths[i] = np.min([peak_index_distance[i - 1], peak_index_distance[i]]) / 2
            # extend midways to a neighboring peak at most
        widths[0] = np.min([peak_index_distance[0] / 2, peak_indices_sorted[0]])
        widths[-1] = np.min([peak_index_distance[-1] / 2, len_tau - 1 - peak_indices_sorted[0]])
        widths = np.array(np.floor(widths[peak_arg_invsort]), dtype=int)
        return widths

    global manual_ecm_pars
    manual_ecm_pars = ManualECMPars(n=num_peak)  # overwrites the current manual_ecm_pars
    if num_peak > 2:
        peak_widths = get_peak_width(peak_indices, tau_out)
        for i in range(num_peak):
            elem = ManualECMElement()
            elem.taumin = tau_out[max(0, peak_indices[i] - peak_widths[i])]
            elem.taumax = tau_out[min(len(tau_out) - 1, peak_indices[i] + peak_widths[i])]
            manual_ecm_pars.set(i + 1, elem)
    elif num_peak == 2:
        index_tau_middle = int((peak_indices[0] + peak_indices[1]) / 2 + 0.499)
        tau_middle = tau_out[index_tau_middle]
        elem = ManualECMElement()
        elem.taumin = tau_out[0]
        elem.taumax = tau_middle
        manual_ecm_pars.set(0, elem)

        elem = ManualECMElement()
        elem.taumin = tau_middle
        elem.taumax = tau_out[-1]
        manual_ecm_pars.set(1, elem)
    elif num_peak == 1:
        elem = ManualECMElement()
        elem.taumin = tau_out[0]
        elem.taumax = tau_out[-1]
        manual_ecm_pars.set(1, elem)
    else:  # num_peak <= 0
        from tkinter.messagebox import showwarning
        message_fail = 'Failed auto setting ECM parameters.'
        showwarning(title=title, message=message_fail)
    _display_m_ecm_after_loading(plot=False)
    current_drt_data = L, R_inf, gamma, tau_out, phi, weights, settings
    plot_manual_ecm_element_into_gui(current_drt_data=current_drt_data)
    root.update_idletasks()

def _command_for_Button_sort_ecm_constrains(reverse=False):
    elem = read_manual_ecm_element_from_gui()
    manual_ecm_pars.set(get_spinbox_value(spinbox_m_ecm_id, default=float('nan')), elem)
    manual_ecm_pars.sort_tau(reverse=reverse)
    elem = manual_ecm_pars.get(get_spinbox_value(spinbox_m_ecm_id, default=1))
    load_manual_ecm_element_into_gui(elem)
    root.update_idletasks()

def command_for_Button_sort_a_ecm_constrains(event=None):
    _command_for_Button_sort_ecm_constrains(reverse=False)

def command_for_Button_sort_d_ecm_constrains(event=None):
    _command_for_Button_sort_ecm_constrains(reverse=True)

def command_for_path_entry(event=None):
    # reference: https://www.python-course.eu/tkinter_entry_widgets.php
    global path_text_entry
    directory = path_text_entry.get()
    if path.isfile(directory):
        directory = path.split(directory)[0]
    list_dir_in_filelist(directory)
    # sys.stdout.flush()

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    # message popup reference:
    # https://docs.python.org/3.9/library/tkinter.messagebox.html
    import EISART
    EISART.vp_start_gui()
